---
title: Project Structure
description: Understand the full-stack architecture of deco applications
icon: Folder
---

import Callout from "../../components/ui/Callout.astro";

deco applications are organized as **full-stack TypeScript monorepos**. Your backend (MCP server) and frontend (React app) live in the same codebase, share types, and deploy together—no integration code required.

<Callout type="info">
  **Key advantage**: Changes to backend tools automatically flow to your frontend through typed RPC. No REST APIs, no OpenAPI specs, no integration layer—just TypeScript.
</Callout>

## Directory Structure

```
my-ai-app/
├── package.json          # Root workspace scripts (dev, gen, deploy)
├── tsconfig.json         # Shared TypeScript configuration
│
├── server/               # Backend: MCP Server (Cloudflare Worker)
│   ├── main.ts          # Server entry point
│   ├── deco.gen.ts      # Auto-generated types (never edit)
│   │
│   ├── tools/           # Tool definitions by domain
│   │   ├── index.ts     # Central export for all tools
│   │   ├── todos.ts     # Example: Todo CRUD tools
│   │   └── user.ts      # Example: User management tools
│   │
│   ├── workflows/       # Workflow orchestrations
│   │   └── index.ts     # Central export for all workflows
│   │
│   ├── schema.ts        # Database schema (Drizzle ORM + SQLite)
│   ├── db.ts            # Database connection helper
│   ├── drizzle.config.ts # Drizzle configuration
│   ├── drizzle/         # Database migration files
│   └── wrangler.toml    # Cloudflare Workers config
│
└── view/                # Frontend: React App (Vite + TanStack Router)
    ├── src/
    │   ├── main.tsx     # App entry point with router
    │   │
    │   ├── routes/      # Page components (TanStack Router)
    │   │   └── home.tsx # Example: Homepage route
    │   │
    │   ├── components/  # Reusable UI components
    │   │   ├── ui/      # shadcn/ui design system
    │   │   └── ...      # Custom components
    │   │
    │   ├── hooks/       # Custom React hooks
    │   │   └── useToolCalls.ts # Example: Tool call wrapper
    │   │
    │   ├── lib/         # Core utilities
    │   │   ├── rpc.ts   # Typed RPC client (calls backend)
    │   │   └── utils.ts # General utilities
    │   │
    │   └── styles.css   # Tailwind CSS styles
    │
    ├── public/          # Static assets (images, fonts)
    ├── vite.config.ts   # Vite bundler configuration
    ├── components.json  # shadcn/ui configuration
    └── package.json     # Frontend dependencies
```

<Callout type="success">
  **One codebase, one deployment**: `npm run deploy` bundles and deploys both backend and frontend together. No Vercel + Railway split, no CORS headaches, no version mismatches.
</Callout>

## The Full-Stack Flow

Here's how the pieces connect:

1. **Define a tool** in `server/tools/` (e.g., `SEND_EMAIL`)
2. **Run `npm run gen:self`** to regenerate `deco.gen.ts` with types
3. **Import `client` in your React component** and call `client.tools.SEND_EMAIL(...)`
4. **TypeScript enforces correctness** at compile time—no runtime surprises

This eliminates the traditional backend/frontend split. Your UI and agent logic share the same tools, the same database, the same auth—everything is unified.

## Backend: Server (`/server`)

Your backend is a **Cloudflare Worker** that serves three purposes:

1. **MCP Server** – Exposes tools/workflows to AI agents at `/mcp`
2. **RPC Endpoint** – Lets your React UI call tools/workflows via typed RPC
3. **Static Asset Host** – Serves your built React app at `/`

All three share the same runtime, the same environment, the same context.

### `main.ts` - Core Server Logic

The main entry point imports from organized directories:

```typescript
import { DefaultEnv, withRuntime } from "@deco/workers-runtime";
import { type Env as DecoEnv, StateSchema } from "./deco.gen.ts";

import { workflows } from "./workflows/index.ts";
import { tools } from "./tools/index.ts";
import { views } from "./views.ts";

export type Env = DefaultEnv & DecoEnv & {
  ASSETS: {
    fetch: (request: Request) => Promise<Response>;
  };
};

const runtime = withRuntime<Env, typeof StateSchema>({
  oauth: {
    scopes: ["AI_GENERATE", "AI_GENERATE_OBJECT"],
    state: StateSchema,
  },
  views,
  workflows,
  tools,
  fetch: fallbackToView("/"), // Serves React app assets
});

export const Workflow = runtime.Workflow;
export default runtime;
```

#### Understanding OAuth Scopes

The `scopes` array defines the permissions your app requests when users install it:

- **`AI_GENERATE`**: Allows your app to use the user's AI Gateway for text generation
- **`AI_GENERATE_OBJECT`**: Enables structured object generation using the user's AI models

When users authorize these scopes, you can access `env.DECO_CHAT_WORKSPACE_API.AI_GENERATE` 
and similar methods without deploying your own AI infrastructure or managing API keys.

#### Understanding State Schema

The `StateSchema` defines the configuration form users see when installing your app. 
This enables multi-tenant functionality where different users can have different configurations 
for the same app.

The state schema is automatically generated from your app's binding dependencies. 
You can extend it to add custom fields:

```typescript
// Example: Extending state schema for API keys
import { StateSchema as BaseSchema } from "./deco.gen.ts";

const ExtendedSchema = BaseSchema.extend({
  apiKey: z.string().describe("Your third-party API key"),
  environment: z.enum(["development", "production"]).default("development"),
});
```

Users fill out this form during installation, and the values are available in 
your `env.DECO_REQUEST_CONTEXT.state` object throughout your application.

### `tools/` - Tool Definitions

Tools are now organized by domain in separate files with a central export:

#### `tools/index.ts` - Central Tool Export
```typescript
import { todoTools } from "./todos.ts";
import { userTools } from "./user.ts";

// Export all tools from all domains
export const tools = [
  ...todoTools,
  ...userTools,
];

// Re-export domain-specific tools for direct access if needed
export { todoTools } from "./todos.ts";
export { userTools } from "./user.ts";
```

#### `tools/todos.ts` - Todo Domain Tools
```typescript
import { createTool } from "@deco/workers-runtime";

export const createListTodosTool = (env: Env) =>
  createTool({
    id: "LIST_TODOS",
    description: "List all todos",
    inputSchema: z.object({}),
    outputSchema: z.object({
      todos: z.array(z.object({
        id: z.number(),
        title: z.string().nullable(),
        completed: z.boolean(),
      })),
    }),
    execute: async () => {
      const db = await getDb(env);
      const todos = await db.select().from(todosTable);
      return { todos };
    },
  });

export const todoTools = [
  createListTodosTool,
  // ... other todo tools
];
```

### `workflows/` - Workflow Definitions

Workflows are organized by domain with a central export:

#### `workflows/index.ts` - Central Workflow Export
```typescript
// Import workflow arrays from domain files
// import { todoWorkflows } from "./todos.ts";
// import { userWorkflows } from "./user.ts";

// Export all workflows from all domains
export const workflows = [
  // ...todoWorkflows,
  // ...userWorkflows,
];

// Re-export domain-specific workflows for direct access if needed
// export { todoWorkflows } from "./todos.ts";
// export { userWorkflows } from "./user.ts";
```

#### Domain-specific Workflow Files
When you add workflows, create domain files like `workflows/todos.ts`:

```typescript
import { createWorkflow, createStepFromTool } from "@deco/workers-runtime";

const createMyWorkflow = (env: Env) => {
  const step = createStepFromTool(createMyTool(env));
  
  return createWorkflow({
    id: "MY_WORKFLOW",
    inputSchema: z.object({ name: z.string() }),
    outputSchema: z.object({ message: z.string() }),
  })
    .then(step)
    .commit();
};

export const todoWorkflows = [createMyWorkflow];
```

### `views.ts` - View Configurations

External React apps that can be installed with your MCP:

```typescript
export const views = () => [
  {
    title: "My App",
    icon: "dashboard",
    url: "https://my-app.deco.page",
  },
];
```

### `deco.gen.ts` - Generated Types

Auto-generated TypeScript types for integrations. **Never edit manually.**

```bash
# Regenerate after adding integrations
npm run gen

# Generate types for your own tools
npm run gen:self
```

### `schema.ts` - Database Schema

Define your database tables using Drizzle ORM:

```typescript
import { integer, sqliteTable, text } from "@deco/workers-runtime/drizzle";

export const todosTable = sqliteTable("todos", {
  id: integer("id").primaryKey(),
  title: text("title"),
  completed: integer("completed").default(0),
});
```

### `db.ts` - Database Helper

Database connection helper:

```typescript
import { getDatabase } from "@deco/workers-runtime/drizzle";
import type { Env } from "./main.ts";
import * as schema from "./schema.ts";

export const getDb = (env: Env) => getDatabase(env, schema);
```

### `wrangler.toml` - Configuration

Cloudflare Workers configuration:

```toml
name = "my-mcp-project"
main = "main.ts"
compatibility_date = "2025-06-17"
compatibility_flags = ["nodejs_compat"]

[assets]
directory = "./view-build"
binding = "ASSETS"

[deco]
workspace = "deco.cx"
bindings = []
enable_workflows = true

[durable_objects]
[[durable_objects.bindings]]
name = "DECO_CHAT_WORKFLOW_DO"
class_name = "Workflow"
```

<Callout type="info">
  Integrations added via `deco add` automatically update this file.
</Callout>

## Frontend: View (`/view`)

Your frontend is a **React application** built with modern tooling. Unlike traditional setups where you build REST APIs to connect frontend and backend, deco uses **typed RPC**—your React components call backend tools directly, with full type safety.

<Callout type="success">
  **No API layer**: Call backend tools from React like local functions. TypeScript ensures you pass correct arguments and handle correct return types—at compile time.
</Callout>

### App Structure

```
view/src/
├── main.tsx            # App entry point with router setup
├── routes/             # Page components (TanStack Router)
│   └── home.tsx       # Homepage route
├── components/         # Reusable UI components
│   ├── ui/            # shadcn/ui design system components
│   └── ...            # Your custom components
├── hooks/             # Custom React hooks
│   └── useToolCalls.ts # Example: Tool call wrapper
├── lib/               # Core utilities
│   ├── rpc.ts         # Typed RPC client (your main interface)
│   └── utils.ts       # General utilities
└── styles.css         # Tailwind CSS styles
```

### Typed RPC Client

The RPC client is your gateway to the backend. It's **auto-generated from your tools and workflows**, so changes to the backend automatically flow to the frontend.

#### Standard RPC Client

```typescript
// view/src/lib/rpc.ts
import { createClient } from "@deco/workers-runtime/client";
import type { Env } from "../../server/deco.gen.ts";

type SelfMCP = Env["SELF"];
export const client = createClient<SelfMCP>();
```

#### How It Works

1. **Backend defines a tool** (e.g., `SEND_EMAIL` in `server/tools/`)
2. **Run `npm run gen:self`** to regenerate types
3. **Frontend gets typed method** (e.g., `client.tools.SEND_EMAIL(...)`)

Example usage:

```typescript
import { client } from "../lib/rpc";

// TypeScript knows the exact input/output types
const result = await client.tools.SEND_EMAIL({
  to: "user@example.com",  // ✅ Type-checked
  subject: "Welcome!",      // ✅ Autocomplete works
  body: "Thanks for signing up.",
});

// result.success is typed as boolean
console.log(result.success);
```

<Callout type="info">
  **Behind the scenes**: The RPC client makes HTTP requests to your Cloudflare Worker, which routes them to the appropriate tool/workflow. But from your perspective, it's just a function call.
</Callout>

#### Logged RPC Client (Debugging)

For debugging, use the logged client that prints requests/responses:

```typescript
// view/src/lib/rpc-logged.ts
import { createLoggedClient } from "@deco/workers-runtime/client";
import type { Env } from "../../server/deco.gen.ts";

type SelfMCP = Env["SELF"];
export const loggedClient = createLoggedClient<SelfMCP>();
```

Switch to `loggedClient` during development to see network calls in the console.

### Route Components

Create pages using TanStack Router:

```typescript
// view/src/routes/home.tsx
import { createRoute } from "@tanstack/react-router";
import { client } from "../lib/rpc";

export default (parentRoute) => createRoute({
  getParentRoute: () => parentRoute,
  path: "/",
  component: HomePage,
});

function HomePage() {
  const handleListTodos = async () => {
    const todos = await client.tools.LIST_TODOS({});
    console.log(todos);
  };

  return (
    <div>
      <h1>My App</h1>
      <button onClick={handleListTodos}>Load Todos</button>
    </div>
  );
}
```

### Custom Hooks

The new structure includes a dedicated hooks directory:

```typescript
// view/src/hooks/useToolCalls.ts
import { useState, useCallback } from "react";
import { client } from "../lib/rpc";

export function useToolCalls() {
  const [loading, setLoading] = useState(false);
  
  const callTool = useCallback(async (toolId: string, params: any) => {
    setLoading(true);
    try {
      const result = await client.tools[toolId](params);
      return result;
    } finally {
      setLoading(false);
    }
  }, []);
  
  return { callTool, loading };
}
```


### What Gets Deployed

- **MCP Server**: Available at `/mcp` endpoint for AI agents
- **React App**: Public web interface for your tools
- **Database**: SQLite database with isolated workspace data  
- **Integrations**: OAuth tokens and API credentials (encrypted)

<Callout type="warning">
  React apps are public by default. Add authentication for private features.
</Callout>
