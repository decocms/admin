import {
  DeleteObjectCommand,
  GetObjectCommand,
  ListObjectsCommand,
  PutObjectCommand,
  S3Client,
} from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import { z } from "zod";
import { WELL_KNOWN_ORIGINS } from "../../hosts.ts";
import {
  assertHasWorkspace,
  assertWorkspaceResourceAccess,
} from "../assertions.ts";
import { type AppContext, createToolGroup, getEnv } from "../context.ts";
import { workspaceOrProjectIdConditions } from "../projects/util.ts";

// Regex generated by Cursor on 2025-05-21
// Replace any character that is not a letter, number, or hyphen with a hyphen to not break the bucket name
export const getWorkspaceBucketName = (workspace: string) =>
  `deco-chat-${workspace
    .toLowerCase()
    .replace(/[^a-z0-9]/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "")}`;

const ensureBucketCorsConfiguration = async (
  c: AppContext,
  bucketName: string,
) => {
  const { cf } = c;
  const env = getEnv(c);

  await cf.r2.buckets.cors.update(bucketName, {
    account_id: env.CF_ACCOUNT_ID,
    rules: [
      {
        maxAgeSeconds: 3600,
        exposeHeaders: ["etag"],
        allowed: {
          methods: ["GET", "PUT"],
          origins: [...WELL_KNOWN_ORIGINS],
          headers: ["origin", "content-type"],
        },
      },
    ],
  });
};

export const ensureBucketExists = async (c: AppContext, bucketName: string) => {
  const { cf } = c;
  const env = getEnv(c);

  try {
    await cf.r2.buckets.get(bucketName, {
      account_id: env.CF_ACCOUNT_ID,
    });

    // We can remove this after some time. This is for ensuring
    // existing buckets have the correct cors configuration.
    await ensureBucketCorsConfiguration(c, bucketName);
  } catch (error) {
    if ((error as unknown as { status: number })?.status !== 404) {
      throw error;
    }

    // Create bucket
    await cf.r2.buckets.create({
      name: bucketName,
      account_id: env.CF_ACCOUNT_ID,
    });

    await ensureBucketCorsConfiguration(c, bucketName);
  }
};

const getS3Client = (c: AppContext) => {
  const env = getEnv(c);

  return new S3Client({
    region: "auto",
    endpoint: `https://${env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com`,
    credentials: {
      accessKeyId: env.CF_R2_ACCESS_KEY_ID!,
      secretAccessKey: env.CF_R2_SECRET_ACCESS_KEY!,
    },
  });
};

/**
 * Calling this function to get a presigned URL without checking authorization
 * could leak files to unauthorized users. Only use this for files you are sure
 * are public.
 *
 * Why i didn't made the file public on write with ACL? R2 does not support it :(
 */
export const getPresignedReadUrl_WITHOUT_CHECKING_AUTHORIZATION = ({
  c,
  existingBucketName,
  path,
  expiresIn = 60,
}: {
  c: AppContext;
  existingBucketName: string;
  path: string;
  expiresIn?: number;
}) => {
  const s3Client = getS3Client(c);
  const getCommand = new GetObjectCommand({
    Bucket: existingBucketName,
    Key: path,
  });
  return getSignedUrl(s3Client, getCommand, { expiresIn });
};

const createTool = createToolGroup("FS", {
  name: "File System",
  description: "Manage file uploads, downloads, and metadata.",
  icon: "https://assets.decocache.com/mcp/0c865439-2b5e-4d8e-8201-e07a9d35ac7c/File-System.png",
});

export const listFiles = createTool({
  name: "FS_LIST",
  description: "List files from a given bucket given a prefix",
  inputSchema: z.lazy(() =>
    z.object({
      prefix: z.string().describe("The root directory to list files from"),
    }),
  ),
  outputSchema: z.lazy(() =>
    z.object({
      items: z.array(z.any()),
    }),
  ),
  handler: async ({ prefix }, c) => {
    assertHasWorkspace(c);
    const bucketName = getWorkspaceBucketName(c.workspace.value);

    await Promise.all([
      ensureBucketExists(c, bucketName),
      assertWorkspaceResourceAccess(c),
    ]);

    const s3Client = getS3Client(c);
    const listCommand = new ListObjectsCommand({
      Bucket: bucketName,
      Prefix: prefix,
    });

    const response = await s3Client.send(listCommand);
    return { items: response.Contents || [] };
  },
});

export const readFile = createTool({
  name: "FS_READ",
  description: "Get a secure temporary link to read a file",
  inputSchema: z.lazy(() =>
    z.object({
      path: z.string(),
      expiresIn: z
        .number()
        .optional()
        .describe("Seconds until URL expires (default: 60)"),
    }),
  ),
  outputSchema: z.lazy(() =>
    z.object({
      url: z.string().describe("The URL to read the file from"),
    }),
  ),
  handler: async ({ path, expiresIn = 180 }, c) => {
    assertHasWorkspace(c);
    const bucketName = getWorkspaceBucketName(c.workspace.value);

    await Promise.all([
      ensureBucketExists(c, bucketName),
      assertWorkspaceResourceAccess(c),
    ]);

    const s3Client = getS3Client(c);
    const getCommand = new GetObjectCommand({
      Bucket: bucketName,
      Key: path,
    });

    const url = await getSignedUrl(s3Client, getCommand, { expiresIn });

    return { url };
  },
});

export const readFileMetadata = createTool({
  name: "FS_READ_METADATA",
  description: "Get metadata about a file",
  inputSchema: z.lazy(() =>
    z.object({
      path: z.string(),
    }),
  ),
  handler: async ({ path }, c) => {
    assertHasWorkspace(c);
    const bucketName = getWorkspaceBucketName(c.workspace.value);

    await Promise.all([
      ensureBucketExists(c, bucketName),
      assertWorkspaceResourceAccess(c),
    ]);

    const s3Client = getS3Client(c);
    const getCommand = new GetObjectCommand({
      Bucket: bucketName,
      Key: path,
    });

    const response = await s3Client.send(getCommand);

    return {
      metadata: response.Metadata,
    };
  },
});

export const writeFile = createTool({
  name: "FS_WRITE",
  description: "Get a secure temporary link to upload a file",
  inputSchema: z.lazy(() =>
    z.object({
      path: z.string(),
      expiresIn: z
        .number()
        .optional()
        .describe("Seconds until URL expires (default: 60)"),
      contentType: z
        .string()
        .describe("Content-Type for the file. This is required."),
      metadata: z
        .record(z.string(), z.any())
        .optional()
        .describe("Metadata to be added to the file"),
    }),
  ),
  outputSchema: z.lazy(() =>
    z.object({
      url: z.string().describe("The URL to upload the file to"),
    }),
  ),
  handler: async ({ path, expiresIn = 60, contentType, metadata }, c) => {
    await assertWorkspaceResourceAccess(c);
    assertHasWorkspace(c);
    const bucketName = getWorkspaceBucketName(c.workspace.value);

    await Promise.all([
      ensureBucketExists(c, bucketName),
      assertWorkspaceResourceAccess(c),
    ]);

    const s3Client = getS3Client(c);
    const putCommand = new PutObjectCommand({
      Bucket: bucketName,
      Key: path,
      ContentType: contentType,
      Metadata: metadata,
    });

    const url = await getSignedUrl(s3Client, putCommand, {
      expiresIn,
      signableHeaders: new Set(["content-type"]),
    });

    return { url };
  },
});

export const deleteFile = createTool({
  name: "FS_DELETE",
  description: "Delete a file",
  inputSchema: z.lazy(() => z.object({ path: z.string() })),
  handler: async ({ path }, c) => {
    assertHasWorkspace(c);
    const bucketName = getWorkspaceBucketName(c.workspace.value);

    await ensureBucketExists(c, bucketName);

    await assertWorkspaceResourceAccess(c);

    const s3Client = getS3Client(c);
    const deleteCommand = new DeleteObjectCommand({
      Bucket: bucketName,
      Key: path,
    });

    const { error } = await c.db
      .from("deco_chat_assets")
      .delete()
      .or(await workspaceOrProjectIdConditions(c))
      .eq("file_url", path)
      .select()
      .single();

    if (error) {
      console.log(
        `failed deleting file: ${path} - workspace: ${c.workspace.value}`,
      );
    }

    return s3Client.send(deleteCommand);
  },
});
