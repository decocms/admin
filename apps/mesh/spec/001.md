# The First-Ever OSS MCP Mesh Specification

## Introduction

The advent of Large Language Models (LLMs) has fundamentally changed how we interact with software. Instead of searching on Google, people now converse with AI assistants. This evolution took another leap when LLMs gained the ability to execute software directly through "tools"—functions that take inputs and return outputs.

Initially, these tools ran in the same runtime environment as the LLM. However, the introduction of the Model Context Protocol (MCP) changed this paradigm. MCP provides a standardized way for AI systems to discover and invoke tools across process boundaries, enabling any service to expose its capabilities to AI agents in a consistent manner.

### The Problem

This new paradigm introduces significant challenges for teams and organizations:

**Connection Management**: Users must manage connections to numerous MCP services, each with its own authentication, payment, and configuration requirements.

**Access Control & Privacy**: There's no way to share MCP access within a team without sharing personal credentials. For example, if your team needs to send emails via an MCP tool, someone must connect their personal Gmail account for everyone to use—creating security risks and privacy concerns.

**Tool Orchestration**: MCP services operate in isolation, with no standard way to compose tools from multiple services or manage dependencies between them.

### Our Solution: MCP Mesh

We're building the first open-source MCP Mesh — a unified platform that solves these challenges by:

1. **Centralizing MCP connections**: Connect all your MCP services in one place with unified authentication

2. **Fine-grained access control**: Create teams and members with precise permissions:
   - Grant specific users access to specific MCP services
   - Share a single connection across your team without exposing credentials
   - Audit who accessed which tools and when
   - Revoke access instantly without changing passwords

3. **Enabling tool composition**: Allow MCP services to depend on each other, eliminating redundant account connections

4. **Providing zero-config deployment**: Run the MCP Mesh locally without complex setup

5. **Being MCP-native**: The Mesh itself exposes an MCP interface, allowing it to be used by any MCP-compatible client

### Apps: Extending MCP

In MCP Mesh, we use "App" and "MCP service" interchangeably. Apps are a superset of MCP — we extend the protocol to support additional features such as:

- **Native multi-tenancy**: Apps can expose configuration schemas via tool calls, which the Mesh renders as user-friendly forms
- **Tool dependencies**: Apps can declare dependencies on other apps' tools
- **Unified discovery**: Browse and install apps from a centralized marketplace
- **Team-based ACLs**: Built-in support for team hierarchies, roles, and fine-grained permissions

The result is a composable, secure, open-source infrastructure layer for the AI-native software era.

---

## Key Architectural Decisions

1. **Project-First Namespacing**: All operations are scoped to projects. Projects provide complete isolation for connections, policies, teams, and audit logs.

2. **MCP-Native API**: Instead of REST, the Mesh uses MCP tools for all management operations. This makes the Mesh itself an MCP service that can be accessed programmatically or via AI agents.

3. **Minimal Configuration**: Only one environment variable (`DATABASE_URL`). All authentication configuration is file-based (`auth-config.json`).

4. **JWT with Audience Claims**: Project-scoped tokens include an `aud` claim matching the project slug, enabling strong isolation and preventing cross-project token reuse.

5. **Policy-Based Access Control**: Fine-grained permissions via Statements → Policies → Roles hierarchy, inspired by AWS IAM.

6. **Zero-Config SQLite**: Uses Bun's native SQLite by default. No database setup required. Upgrade to PostgreSQL when needed.

7. **Credential Isolation**: Original service tokens never leave the Mesh. The proxy replaces Mesh tokens with actual credentials at request time.

8. **Hierarchical URL Structure**:
   - `/mcp` - Project management (root level)
   - `/:project/mcp` - All project-scoped operations
   - `/:project/mcp/:connection` - MCP proxy to external services

---

## Implementation Architecture

### Code Organization

The codebase is organized to maintain clear separation of concerns between the HTTP API layer and the business logic (tools).

```
apps/mesh/
├── src/
│   ├── api/
│   │   ├── index.ts                 # Hono app initialization
│   │   ├── middlewares/
│   │   │   ├── inject-context.ts    # Middleware that injects MeshContext into requests
│   │   │   ├── auth.ts              # Authentication middleware
│   │   │   ├── project-scope.ts     # Project validation middleware
│   │   │   └── authorization.ts     # Authorization verification middleware
│   │   └── routes/
│   │       ├── root-mcp.ts          # /mcp routes (project management)
│   │       ├── project-mcp.ts       # /:project/mcp routes
│   │       └── proxy.ts             # /:project/mcp/:connection routes
│   │
│   ├── tools/
│   │   ├── project/
│   │   │   ├── create.ts            # PROJECT_CREATE
│   │   │   ├── list.ts              # PROJECT_LIST
│   │   │   ├── get.ts               # PROJECT_GET
│   │   │   ├── update.ts            # PROJECT_UPDATE
│   │   │   └── delete.ts            # PROJECT_DELETE
│   │   ├── connection/
│   │   │   ├── create.ts            # CONNECTION_CREATE
│   │   │   ├── list.ts              # CONNECTION_LIST
│   │   │   └── ...
│   │   ├── policy/
│   │   ├── role/
│   │   ├── token/
│   │   └── audit/
│   │
│   ├── core/
│   │   ├── mesh-context.ts          # MeshContext interface definition
│   │   ├── context-factory.ts       # Factory function to create MeshContext
│   │   └── access-control.ts        # Access control helper for authorization
│   │
│   ├── storage/
│   │   ├── ports.ts                 # Storage port interfaces (contracts)
│   │   └── adapters/
│   │       ├── sqlite/
│   │       │   ├── connection.ts    # SQLite ConnectionStorage adapter
│   │       │   ├── policy.ts        # SQLite PolicyStorage adapter
│   │       │   ├── project.ts       # SQLite ProjectStorage adapter
│   │       │   └── ...
│   │       └── postgres/
│   │           ├── connection.ts    # PostgreSQL ConnectionStorage adapter
│   │           ├── policy.ts        # PostgreSQL PolicyStorage adapter
│   │           └── ...
│   │
│   ├── auth/
│   │   ├── jwt-issuer.ts            # JWT token creation/validation
│   │   └── better-auth.ts           # Better Auth integration
│   │
│   └── encryption/
│       └── credential-vault.ts      # Credential encryption/decryption
```

### Architecture Principles

#### 1. Separation of Concerns

**API Layer Responsibilities:**

- HTTP request/response handling
- Middleware orchestration
- Context creation and injection
- Error handling and formatting
- Route definitions

**Tool Layer Responsibilities:**

- Business logic execution
- Data validation
- Authorization checks
- Storage operations via context interfaces

**Tools must NOT:**

- Access HTTP request/response objects directly
- Know about Hono or any HTTP framework details
- Import database drivers directly
- Handle HTTP status codes

#### 2. MeshContext: The Core Abstraction

Every tool receives a `MeshContext` that provides access to all necessary services through well-defined interfaces:

```typescript
// core/mesh-context.ts
interface MeshContext {
  // Authentication
  auth: {
    user?: User;
    session?: Session;
    token?: ParsedToken;
  };
  
  // Project scope (for project-scoped endpoints)
  project?: {
    id: string;
    slug: string;
    ownerId: string;
  };
  
  // Storage interfaces
  storage: {
    projects: ProjectStorage;
    connections: ConnectionStorage;
    policies: PolicyStorage;
    roles: RoleStorage;
    tokens: AccessTokenStorage;
    teams: TeamStorage;
    auditLogs: AuditLogStorage;
  };
  
  // Security services
  jwt: JWTIssuer;
  vault: CredentialVault;
  
  // Access control (for authorization)
  access: AccessControl;
  
  // Request metadata (non-HTTP specific)
  metadata: {
    requestId: string;
    timestamp: Date;
    userAgent?: string;
    ipAddress?: string;
  };
}
```

#### 3. Authorization Pattern

Tools must explicitly authorize operations. The authorization flow follows this pattern:

**Step 1: Middleware Injects Context**

```typescript
// api/middlewares/inject-context.ts
app.use('*', async (c, next) => {
  const ctx: MeshContext = await createMeshContext(c);
  c.set('meshContext', ctx);
  await next();
});
```

**Step 2: Tool Pipeline Checks Policies (Non-Blocking)**

```typescript
// api/middlewares/authorization.ts
app.use('/mcp/tools/*', async (c, next) => {
  const ctx = c.get('meshContext');
  const toolName = extractToolName(c.req.path);
  
  // Check if user has policies that MIGHT allow this tool
  // This is a pre-check, not enforcement
  const hasRelevantPolicies = await ctx.storage.policies.userHasPolicies(
    ctx.auth.user?.id,
    ctx.project?.id
  );
  
  if (!hasRelevantPolicies) {
    throw new ForbiddenError('No policies found for user');
  }
  
  // Continue - tool will do fine-grained check
  await next();
});
```

**Step 3: Tool Explicitly Grants Access**

```typescript
// tools/connection/create.ts
export async function CONNECTION_CREATE(
  ctx: MeshContext,
  args: ConnectionCreateArgs
): Promise<ConnectionCreateResult> {
  // Tool validates input
  const validated = ConnectionCreateSchema.parse(args);
  
  // Tool performs authorization check
  const canCreateConnection = await ctx.storage.policies.evaluate({
    userId: ctx.auth.user!.id,
    projectId: ctx.project!.id,
    action: 'CONNECTION_CREATE',
    resource: '*',
  });
  
  if (!canCreateConnection) {
    throw new UnauthorizedError('Not allowed to create connections');
  }
  
  // EXPLICIT GRANT - Required!
  ctx.access.grant({
    action: 'CONNECTION_CREATE',
    reason: 'User has policy allowing connection creation',
  });
  
  // Perform the actual work
  const connection = await ctx.storage.connections.create({
    projectId: ctx.project!.id,
    ...validated,
  });
  
  // Log the action
  await ctx.storage.auditLogs.log({
    projectId: ctx.project!.id,
    userId: ctx.auth.user!.id,
    toolName: 'CONNECTION_CREATE',
    allowed: true,
    metadata: { connectionId: connection.id },
  });
  
  return connection;
}
```

**Step 4: Final Middleware Verifies Grant**

```typescript
// api/middlewares/authorization.ts
app.use('*', async (c, next) => {
  await next();
  
  // After tool execution, verify authorization was handled
  const ctx = c.get('meshContext');
  
  if (!ctx.access.wasGranted() && !ctx.access.wasDenied()) {
    // Tool forgot to call grant() or explicitly deny
    throw new Error('SECURITY: Tool did not perform authorization check');
  }
});
```

#### 4. Storage Port & Adapter Pattern

Storage ports define the contracts, and adapters implement them for specific databases:

```typescript
// storage/ports.ts
export interface ConnectionStorage {
  create(data: CreateConnectionData): Promise<MCPConnection>;
  findById(id: string): Promise<MCPConnection | null>;
  findByProjectId(projectId: string): Promise<MCPConnection[]>;
  update(id: string, data: Partial<MCPConnection>): Promise<MCPConnection>;
  delete(id: string): Promise<void>;
  
  // Connection-specific queries
  findByTeamId(teamId: string): Promise<MCPConnection[]>;
  testConnection(id: string): Promise<ConnectionTestResult>;
}

// storage/adapters/sqlite/connection.ts
export class SQLiteConnectionAdapter implements ConnectionStorage {
  constructor(private db: Database) {}
  
  async create(data: CreateConnectionData): Promise<MCPConnection> {
    const stmt = this.db.prepare(`
      INSERT INTO connections (id, project_id, name, connection_type, ...)
      VALUES (?, ?, ?, ?, ...)
    `);
    // ... implementation
  }
  
  // ... other methods
}
```

#### 5. Context Factory

The context factory creates MeshContext with appropriate storage adapters:

```typescript
// core/context-factory.ts
export interface MeshContextConfig {
  database: {
    type: 'sqlite' | 'postgres';
    url?: string;
  };
  jwt: {
    secret: string;
    issuer: string;
  };
  encryption: {
    key: string;
  };
}

export function createMeshContextFactory(
  config: MeshContextConfig
): (c: Context) => Promise<MeshContext> {
  // Create storage adapters based on config
  const db = config.database.type === 'sqlite' 
    ? new Database(config.database.url || './data/mesh.db')
    : createPostgresPool(config.database.url!);
  
  const storage = {
    projects: new SQLiteProjectAdapter(db),
    connections: new SQLiteConnectionAdapter(db),
    policies: new SQLitePolicyAdapter(db),
    // ... other storage adapters
  };
  
  const jwt = new JWTIssuer(config.jwt);
  const vault = new CredentialVault(config.encryption.key);
  
  // Return factory function
  return async (c: Context): Promise<MeshContext> => {
    // Extract auth from request
    const authHeader = c.req.header('Authorization');
    const token = authHeader?.replace('Bearer ', '');
    
    let auth: MeshContext['auth'] = {};
    if (token) {
      const parsed = await jwt.verify(token);
      auth = {
        user: await storage.users.findById(parsed.userId),
        token: parsed,
      };
    }
    
    // Extract project from path
    const projectSlug = extractProjectSlug(c.req.path);
    let project: MeshContext['project'] | undefined;
    if (projectSlug) {
      project = await storage.projects.findBySlug(projectSlug);
      
      // Verify token audience matches project
      if (auth.token && auth.token.aud !== projectSlug) {
        throw new UnauthorizedError('Token audience mismatch');
      }
    }
    
    return {
      auth,
      project,
      storage,
      jwt,
      vault,
      access: new AccessControl(),
      metadata: {
        requestId: crypto.randomUUID(),
        timestamp: new Date(),
        userAgent: c.req.header('User-Agent'),
        ipAddress: c.req.header('CF-Connecting-IP') || c.req.header('X-Forwarded-For'),
      },
    };
  };
}
```

#### 6. Tool Registration and Pipeline

```typescript
// api/index.ts
import { Hono } from 'hono';
import { createMeshContextFactory } from '../core/context-factory';
import * as ProjectTools from '../tools/project';
import * as ConnectionTools from '../tools/connection';

const app = new Hono();

// Load configuration
const config = loadConfig();

// Create context factory
const createContext = createMeshContextFactory(config);

// Register middleware
app.use('*', async (c, next) => {
  const ctx = await createContext(c);
  c.set('meshContext', ctx);
  await next();
});

// Tool execution handler
async function executeTool(
  c: Context,
  toolName: string,
  args: unknown
): Promise<unknown> {
  const ctx = c.get('meshContext') as MeshContext;
  
  // Find tool
  const tool = TOOL_REGISTRY[toolName];
  if (!tool) {
    throw new Error(`Unknown tool: ${toolName}`);
  }
  
  // Execute tool
  const result = await tool(ctx, args);
  
  // Verify authorization was checked
  if (!ctx.access.wasGranted() && !ctx.access.wasDenied()) {
    throw new Error(`SECURITY: Tool ${toolName} did not check authorization`);
  }
  
  return result;
}

// Root-level MCP endpoints
app.post('/mcp/tools/:toolName', async (c) => {
  const toolName = c.req.param('toolName');
  const args = await c.req.json();
  
  const result = await executeTool(c, toolName, args);
  return c.json({ result });
});

// Project-scoped MCP endpoints
app.post('/:project/mcp/tools/:toolName', async (c) => {
  const toolName = c.req.param('toolName');
  const args = await c.req.json();
  
  const result = await executeTool(c, toolName, args);
  return c.json({ result });
});

// Tool registry
const TOOL_REGISTRY = {
  PROJECT_CREATE: ProjectTools.create,
  PROJECT_LIST: ProjectTools.list,
  PROJECT_GET: ProjectTools.get,
  CONNECTION_CREATE: ConnectionTools.create,
  CONNECTION_LIST: ConnectionTools.list,
  // ... more tools
};
```

#### 7. Testing Strategy

The MeshContext abstraction enables comprehensive testing without HTTP servers:

```typescript
// tools/connection/create.test.ts
import { describe, it, expect } from 'bun:test';
import { CONNECTION_CREATE } from './create';
import { createMockContext } from '../../test-utils/mock-context';

describe('CONNECTION_CREATE', () => {
  it('creates connection when authorized', async () => {
    // Mock storage adapters
    const mockStorageAdapters = {
      connections: {
        create: async (data) => ({ id: 'conn_123', ...data }),
      },
      policies: {
        evaluate: async () => true, // User is authorized
      },
      auditLogs: {
        log: async () => {},
      },
    };
    
    const ctx = createMockContext({
      auth: { user: { id: 'user_abc' } },
      project: { id: 'proj_xyz', slug: 'test' },
      storage: mockStorageAdapters,
    });
    
    const result = await CONNECTION_CREATE(ctx, {
      name: 'Test Connection',
      connection: { type: 'HTTP', url: 'https://example.com' },
    });
    
    expect(result.id).toBe('conn_123');
    expect(ctx.access.wasGranted()).toBe(true);
  });
  
  it('throws when not authorized', async () => {
    const mockStorageAdapters = {
      policies: {
        evaluate: async () => false, // User is NOT authorized
      },
    };
    
    const ctx = createMockContext({
      auth: { user: { id: 'user_abc' } },
      project: { id: 'proj_xyz', slug: 'test' },
      storage: mockStorageAdapters,
    });
    
    await expect(
      CONNECTION_CREATE(ctx, { name: 'Test', connection: { type: 'HTTP', url: 'https://example.com' } })
    ).rejects.toThrow('Not allowed to create connections');
  });
});
```

### Benefits of This Architecture

1. **Testability**: Tools can be unit tested without spinning up HTTP servers or databases
2. **Flexibility**: Easy to swap storage adapters (SQLite ↔ PostgreSQL) without changing business logic
3. **Security**: Explicit authorization checks prevent accidental bypass
4. **Maintainability**: Clear boundaries between layers (API → Tools → Storage)
5. **Reusability**: Tools can be called from HTTP API, CLI, tests, or other tools
6. **Type Safety**: Strong TypeScript interfaces (ports) throughout, with adapters implementing them
7. **Clear Naming**:
   - `core/` contains cross-cutting concerns (context, factory, access control)
   - `storage/ports.ts` defines contracts
   - `storage/adapters/` implements those contracts for specific databases

### Architecture Naming Clarifications

To avoid confusion and maintain clean separation of concerns:

**Context-Related Files:**

- `core/mesh-context.ts` - The core MeshContext interface definition
- `core/context-factory.ts` - Factory function that creates MeshContext instances
- `core/access-control.ts` - Access control helper for authorization tracking
- `api/middlewares/inject-context.ts` - Hono middleware that injects MeshContext into requests

The `core/` folder contains the heart of the application: the context abstraction and its factory. The middleware simply uses the factory to inject context into HTTP requests.

**Storage Pattern: Ports & Adapters**

We follow the Ports & Adapters pattern (Hexagonal Architecture):

- **Ports** (`storage/ports.ts`): Define the contracts/interfaces that the business logic depends on
- **Adapters** (`storage/adapters/`): Implement those contracts for specific databases

This pattern:

- Makes the business logic (tools) database-agnostic
- Allows easy testing with mock adapters
- Enables switching databases without changing tool code
- Follows dependency inversion principle (depend on abstractions, not implementations)

**Why "Adapter" instead of "Implementation"?**

The term "adapter" is more precise and idiomatic in software architecture:

- "Adapter" implies converting one interface to another (database → port interface)
- "Implementation" is too generic and could refer to any code
- "Adapter" clearly signals the Ports & Adapters pattern
- Industry-standard naming that developers recognize

---

## Technical Architecture

### Runtime & Technology Stack

**Runtime Environment:**

- **Language**: TypeScript on Bun runtime
- **Deployment**: Self-hosted via standalone binary or Docker
- **Supported Platforms**: Linux, macOS, Windows (via WSL2)

**Core Dependencies:**

- **Web Framework**: Hono (lightweight, edge-compatible)
- **Database**: Bun's native SQLite (zero-config default)
- **Database ORM**: Drizzle ORM
- **Authentication**: Better Auth
- **Validation**: Zod
- **JWT Management**: jose library

**Getting Started (Zero Config):**

```bash
# Clone the repository
git clone https://github.com/decocms/admin.git
cd admin/apps/mesh

# Install dependencies
bun install

# Start the server (SQLite database created automatically)
bun run start
```

That's it! The Mesh will automatically:

- Create a local SQLite database at `./data/mesh.db`
- Run all necessary migrations
- Start the server on `http://localhost:3000`
- Expose all management features via MCP protocol at `/mcp`

**Optional Configuration:**

Only one environment variable is supported:

```bash
# Optional: Use PostgreSQL instead of SQLite
DATABASE_URL=postgresql://user:pass@host:5432/dbname
```

All other configuration (OAuth, SAML, etc.) is done via `auth-config.json`:

```bash
# Create optional auth configuration
cat > auth-config.json << 'EOF'
{
  "socialProviders": {
    "google": {
      "clientId": "your-google-client-id",
      "clientSecret": "your-google-client-secret"
    },
    "github": {
      "clientId": "your-github-client-id", 
      "clientSecret": "your-github-client-secret"
    }
  },
  "saml": {
    "enabled": true,
    "providers": [
      {
        "name": "Okta",
        "entryPoint": "https://your-org.okta.com/app/...",
        "issuer": "http://www.okta.com/...",
        "cert": "-----BEGIN CERTIFICATE-----..."
      }
    ]
  }
}
EOF

# Restart to apply auth configuration
bun run start
```

### Database Model

**Core Entities:**

```typescript
// Users & Authentication
interface User {
  id: string;
  email: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
}

interface Session {
  id: string;
  userId: string;
  expiresAt: Date;
  token: string;
}

// Project Management (Namespaces)
interface Project {
  id: string;
  name: string;
  slug: string; // URL-safe identifier (e.g., "my-project")
  ownerId: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

interface ProjectMember {
  id: string;
  projectId: string;
  userId: string;
  roleIds: string[]; // Array of role IDs
  createdAt: Date;
}

// Team Management (within a project)
interface Team {
  id: string;
  projectId: string;
  name: string;
  ownerId: string;
  createdAt: Date;
}

interface TeamMember {
  id: string;
  teamId: string;
  userId: string;
  roleIds: string[]; // Array of role IDs
  createdAt: Date;
}

// MCP Connections (based on MCPConnection model)
type ConnectionType = 'HTTP' | 'SSE' | 'Websocket';

interface MCPConnection {
  id: string;
  projectId: string;
  teamId?: string; // Optional: scope to specific team
  createdById: string;
  name: string;
  description?: string;
  icon?: string;
  appName?: string;
  appId?: string;
  
  // Connection configuration (discriminated union)
  connection: 
    | { type: 'HTTP'; url: string; token?: string }
    | { type: 'SSE'; url: string; token?: string; headers?: Record<string, string> }
    | { type: 'Websocket'; url: string; token?: string };
  
  metadata?: Record<string, any>;
  tools?: Array<{
    name: string;
    description?: string;
    inputSchema: object;
    outputSchema?: object;
  }>;
  
  status: 'active' | 'inactive' | 'error';
  createdAt: Date;
  updatedAt: Date;
}

// Policy-based Access Control

// Statement: Fine-grained permission rule
interface Statement {
  effect: 'allow' | 'deny';
  resource: string; // TOOL_NAME or pattern like "CONNECTION_*"
  matchCondition?: {
    resource: 'is_integration';
    integrationId: string; // Specific connection ID
  };
}

// Policy: Named set of statements
interface Policy {
  id: string;
  projectId: string;
  name: string;
  description?: string;
  statements: Statement[];
  createdAt: Date;
  updatedAt: Date;
}

// Role: Set of policies
interface Role {
  id: string;
  projectId: string;
  name: string;
  description?: string;
  policyIds: string[];
  createdAt: Date;
  updatedAt: Date;
}

// Access Tokens (for programmatic access)
interface AccessToken {
  id: string;
  projectId: string;
  createdById: string;
  name: string;
  token: string; // JWT token issued by Mesh
  policyIds: string[]; // Directly attached policies
  expiresAt: Date | null;
  createdAt: Date;
  revokedAt: Date | null;
}

// Audit Logs
interface AuditLog {
  id: string;
  projectId: string;
  userId?: string;
  accessTokenId?: string;
  connectionId?: string;
  toolName: string; // The tool that was called
  allowed: boolean; // Whether access was granted
  timestamp: Date;
  requestMetadata: object;
  responseStatus?: number;
  denyReason?: string;
}
```

**Database Technology:**

- **Default**: SQLite via Bun's native `bun:sqlite` (zero configuration required)
- **Optional**: PostgreSQL (for larger deployments or multi-instance setups)
- **Migrations**: Automatically applied on startup via Drizzle Kit

**Why SQLite?**

- Zero configuration - works out of the box
- Perfect for self-hosted single-instance deployments
- Native Bun support for excellent performance
- Simple backup and restore (just copy the `.db` file)
- Upgrade to PostgreSQL anytime without code changes

### Authentication System

**Better Auth Integration:**

MCP Mesh uses Better Auth for flexible authentication with multiple providers. All authentication configuration is done via an optional `auth-config.json` file—no environment variables needed!

**Supported Auth Methods:**

1. **Email/Password**: Enabled by default
2. **OAuth Providers**: Google, GitHub, Microsoft, Generic OAuth 2.0
3. **SSO (SAML)**: Enterprise SSO support

**Configuration via `auth-config.json`:**

The file accepts a partial Better Auth configuration object, allowing you to enable only the providers you need:

```json
{
  "emailAndPassword": {
    "enabled": true
  },
  "socialProviders": {
    "google": {
      "clientId": "your-google-client-id",
      "clientSecret": "your-google-client-secret"
    },
    "github": {
      "clientId": "your-github-client-id",
      "clientSecret": "your-github-client-secret"
    },
    "microsoft": {
      "clientId": "your-microsoft-client-id",
      "clientSecret": "your-microsoft-client-secret"
    }
  },
  "saml": {
    "enabled": true,
    "providers": [
      {
        "name": "Okta",
        "entryPoint": "https://your-org.okta.com/app/...",
        "issuer": "http://www.okta.com/...",
        "cert": "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
      }
    ]
  }
}
```

**Implementation:**

```typescript
import { betterAuth } from "better-auth";
import { Database } from "bun:sqlite";
import { readFileSync, existsSync } from "fs";

// Load optional auth configuration
let authConfig = { emailAndPassword: { enabled: true } };
if (existsSync("./auth-config.json")) {
  authConfig = JSON.parse(readFileSync("./auth-config.json", "utf-8"));
}

// Determine database
const db = process.env.DATABASE_URL 
  ? process.env.DATABASE_URL
  : new Database("./data/mesh.db");

export const auth = betterAuth({
  database: {
    provider: process.env.DATABASE_URL ? "postgres" : "sqlite",
    db,
  },
  ...authConfig, // Spread user configuration
});
```

### Core APIs (MCP Tools)

**MCP-Native API Architecture:**

The Mesh uses a hierarchical namespace structure where all operations are scoped to projects:

**Root-Level APIs** (`/mcp`) - Project Management:

```
POST /mcp/tools/{TOOL_NAME}
Authorization: Bearer <session-token>

// Used for managing projects themselves
```

**Project-Scoped APIs** (`/:project/mcp`) - All other operations:

```
POST /:project/mcp/tools/{TOOL_NAME}
Authorization: Bearer <project-scoped-token>

// Used for connections, policies, teams, etc. within a project
```

**JWT Token Structure:**

Project-scoped tokens include an `aud` (audience) claim:

```typescript
interface MeshTokenPayload {
  // Standard JWT claims
  sub: string;           // Token ID or User ID
  iss: string;           // Mesh instance URL
  iat: number;           // Issued at
  exp: number;           // Expiration
  aud: string;           // Project slug (e.g., "my-project")
  
  // Mesh-specific claims
  projectId: string;     // Project ID
  userId?: string;       // User ID (if user token)
  tokenId?: string;      // Access token ID (if API token)
  policyIds: string[];   // Policy IDs that apply
}
```

**Built-in Management Tools:**

#### Project Management (Root Level: `/mcp`)

**PROJECT_CREATE**

```typescript
// Create a new project
POST /mcp/tools/PROJECT_CREATE
Authorization: Bearer <session-token>
{
  "name": "My Project",
  "slug": "my-project", // URL-safe, unique
  "description": "My awesome project"
}
// Returns: { id: "proj_abc123", slug: "my-project", name: "My Project" }
```

**PROJECT_LIST**

```typescript
// List all projects user has access to
POST /mcp/tools/PROJECT_LIST
Authorization: Bearer <session-token>
{}
// Returns: { projects: [...] }
```

**PROJECT_GET**

```typescript
// Get project details
POST /mcp/tools/PROJECT_GET
Authorization: Bearer <session-token>
{
  "slug": "my-project" // or "id": "proj_abc123"
}
// Returns: { id, slug, name, description, ... }
```

**PROJECT_UPDATE**

```typescript
// Update project
POST /mcp/tools/PROJECT_UPDATE
Authorization: Bearer <session-token>
{
  "slug": "my-project",
  "name": "Updated Name",
  "description": "Updated description"
}
```

**PROJECT_DELETE**

```typescript
// Delete project
POST /mcp/tools/PROJECT_DELETE
Authorization: Bearer <session-token>
{
  "slug": "my-project"
}
```

**PROJECT_MEMBER_ADD**

```typescript
// Add member to project
POST /mcp/tools/PROJECT_MEMBER_ADD
Authorization: Bearer <session-token>
{
  "projectSlug": "my-project",
  "userId": "user_abc",
  "roleIds": ["role_789"]
}
```

**PROJECT_MEMBER_REMOVE**

```typescript
// Remove member from project
POST /mcp/tools/PROJECT_MEMBER_REMOVE
Authorization: Bearer <session-token>
{
  "projectSlug": "my-project",
  "userId": "user_abc"
}
```

---

#### Connection Management (Project-Scoped: `/:project/mcp`)

**CONNECTION_CREATE**

```typescript
// Create a new MCP connection
POST /my-project/mcp/tools/CONNECTION_CREATE
Authorization: Bearer <project-token with aud: "my-project">
{
  "name": "Team Gmail",
  "description": "Gmail integration for the team",
  "icon": "https://...",
  "connection": {
    "type": "HTTP",
    "url": "https://mcp.gmail.com/mcp",
    "token": "gmail-secret-token-XPTO"
  },
  "metadata": {}
}
// Returns: { id: "conn_abc123", name: "Team Gmail", status: "active" }
```

**CONNECTION_LIST**

```typescript
// List all connections in this project
POST /my-project/mcp/tools/CONNECTION_LIST
Authorization: Bearer <project-token>
{
  "teamId": "team_xyz" // Optional filter
}
// Returns: { connections: [...] }
```

**CONNECTION_GET**

```typescript
// Get connection details
POST /my-project/mcp/tools/CONNECTION_GET
Authorization: Bearer <project-token>
{
  "id": "conn_abc123"
}
// Returns: { id, name, description, connection, tools, status, ... }
```

**CONNECTION_UPDATE**

```typescript
// Update connection
POST /my-project/mcp/tools/CONNECTION_UPDATE
Authorization: Bearer <project-token>
{
  "id": "conn_abc123",
  "name": "Updated Gmail",
  "status": "active"
}
```

**CONNECTION_DELETE**

```typescript
// Delete connection
POST /my-project/mcp/tools/CONNECTION_DELETE
Authorization: Bearer <project-token>
{
  "id": "conn_abc123"
}
```

**CONNECTION_TEST**

```typescript
// Test connection health
POST /my-project/mcp/tools/CONNECTION_TEST
Authorization: Bearer <project-token>
{
  "id": "conn_abc123"
}
// Returns: { healthy: true, latencyMs: 45, availableTools: [...] }
```

#### Policy & Access Control Management (Project-Scoped: `/:project/mcp`)

**POLICY_CREATE**

```typescript
// Create a new policy
POST /my-project/mcp/tools/POLICY_CREATE
Authorization: Bearer <project-token>
{
  "name": "Gmail Send Only",
  "description": "Allow only sending emails",
  "statements": [
    {
      "effect": "allow",
      "resource": "SEND_EMAIL",
      "matchCondition": {
        "resource": "is_integration",
        "integrationId": "conn_abc123"
      }
    },
    {
      "effect": "deny",
      "resource": "DELETE_*"
    }
  ]
}
// Returns: { id: "policy_123", name: "Gmail Send Only" }
```

**POLICY_LIST**

```typescript
// List all policies
POST /my-project/mcp/tools/POLICY_LIST
Authorization: Bearer <project-token>
{}
```

**POLICY_UPDATE**

```typescript
// Update policy statements
POST /my-project/mcp/tools/POLICY_UPDATE
Authorization: Bearer <project-token>
{
  "id": "policy_123",
  "statements": [...]
}
```

**POLICY_DELETE**

```typescript
// Delete policy
POST /my-project/mcp/tools/POLICY_DELETE
Authorization: Bearer <project-token>
{
  "id": "policy_123"
}
```

**ROLE_CREATE**

```typescript
// Create a role (set of policies)
POST /my-project/mcp/tools/ROLE_CREATE
Authorization: Bearer <project-token>
{
  "name": "Email Manager",
  "description": "Can manage email operations",
  "policyIds": ["policy_123", "policy_456"]
}
// Returns: { id: "role_789", name: "Email Manager" }
```

**ROLE_LIST**

```typescript
// List all roles
POST /my-project/mcp/tools/ROLE_LIST
Authorization: Bearer <project-token>
{}
```

**ROLE_UPDATE**

```typescript
// Update role
POST /my-project/mcp/tools/ROLE_UPDATE
Authorization: Bearer <project-token>
{
  "id": "role_789",
  "policyIds": ["policy_123", "policy_456", "policy_789"]
}
```

**ROLE_DELETE**

```typescript
// Delete role
POST /my-project/mcp/tools/ROLE_DELETE
Authorization: Bearer <project-token>
{
  "id": "role_789"
}
```

#### Access Token Management (Project-Scoped: `/:project/mcp`)

**TOKEN_CREATE**

```typescript
// Create access token with policies
POST /my-project/mcp/tools/TOKEN_CREATE
Authorization: Bearer <project-token>
{
  "name": "CI/CD Pipeline Token",
  "policyIds": ["policy_123"],
  "expiresIn": "90d" // or null for no expiration
}
// Returns: { 
//   id: "token_xyz789", 
//   token: "mesh_eyJhbGciOiJIUzI1NiIs...", // Has aud: "my-project"
//   expiresAt: "2025-01-26T00:00:00Z"
// }
```

**TOKEN_LIST**

```typescript
// List all tokens
POST /my-project/mcp/tools/TOKEN_LIST
Authorization: Bearer <project-token>
{
  "includeRevoked": false
}
```

**TOKEN_REVOKE**

```typescript
// Revoke a token
POST /my-project/mcp/tools/TOKEN_REVOKE
Authorization: Bearer <project-token>
{
  "id": "token_xyz789"
}
```

#### Team Management (Project-Scoped: `/:project/mcp`)

**TEAM_CREATE**

```typescript
// Create a new team
POST /my-project/mcp/tools/TEAM_CREATE
Authorization: Bearer <project-token>
{
  "name": "Engineering"
}
```

**TEAM_LIST**

```typescript
// List teams
POST /my-project/mcp/tools/TEAM_LIST
Authorization: Bearer <project-token>
{}
```

**TEAM_MEMBER_ADD**

```typescript
// Add member to team
POST /my-project/mcp/tools/TEAM_MEMBER_ADD
Authorization: Bearer <project-token>
{
  "teamId": "team_xyz",
  "userId": "user_abc",
  "roleIds": ["role_789"]
}
```

**TEAM_MEMBER_REMOVE**

```typescript
// Remove member from team
POST /my-project/mcp/tools/TEAM_MEMBER_REMOVE
Authorization: Bearer <project-token>
{
  "teamId": "team_xyz",
  "userId": "user_abc"
}
```

**TEAM_MEMBER_UPDATE_ROLES**

```typescript
// Update member roles
POST /my-project/mcp/tools/TEAM_MEMBER_UPDATE_ROLES
Authorization: Bearer <project-token>
{
  "teamId": "team_xyz",
  "userId": "user_abc",
  "roleIds": ["role_789", "role_101"]
}
```

#### Audit & Monitoring (Project-Scoped: `/:project/mcp`)

**AUDIT_QUERY**

```typescript
// Query audit logs
POST /my-project/mcp/tools/AUDIT_QUERY
Authorization: Bearer <project-token>
{
  "userId": "user_abc", // Optional filter
  "connectionId": "conn_abc123", // Optional filter
  "toolName": "SEND_EMAIL", // Optional filter
  "startDate": "2025-01-01T00:00:00Z",
  "endDate": "2025-01-31T23:59:59Z",
  "limit": 100,
  "offset": 0
}
// Returns: { logs: [...], total: 1234 }
```

**AUDIT_STATS**

```typescript
// Get usage statistics
POST /my-project/mcp/tools/AUDIT_STATS
Authorization: Bearer <project-token>
{
  "groupBy": "tool", // or "connection", "user", "day"
  "startDate": "2025-01-01T00:00:00Z",
  "endDate": "2025-01-31T23:59:59Z"
}
// Returns: { stats: { SEND_EMAIL: 450, READ_INBOX: 1200, ... } }
```

### The MCP Mesh Proxy API

**Core Concept:**

The MCP Mesh Proxy is the heart of the system. It acts as a secure intermediary that:

1. Accepts requests with project-scoped JWT tokens (with `aud` claim)
2. Validates tokens and checks policies
3. Replaces Mesh tokens with actual service credentials
4. Proxies requests to target MCP services
5. Logs all activity for auditing

**How It Works:**

#### Step 1: Create a Project

```bash
POST /mcp/tools/PROJECT_CREATE
Authorization: Bearer <session-token>
Content-Type: application/json

{
  "name": "My Project",
  "slug": "my-project"
}

# Response:
{
  "id": "proj_abc123",
  "slug": "my-project",
  "name": "My Project"
}
```

#### Step 2: Register an MCP Connection

```bash
POST /my-project/mcp/tools/CONNECTION_CREATE
Authorization: Bearer <project-token with aud: "my-project">
Content-Type: application/json

{
  "name": "Team Gmail",
  "description": "Gmail integration for the team",
  "connection": {
    "type": "HTTP",
    "url": "https://mcp.gmail.com/mcp",
    "token": "gmail-secret-token-XPTO"
  }
}

# Response:
{
  "id": "conn_abc123",
  "name": "Team Gmail",
  "status": "active"
}
```

The Mesh encrypts and stores `gmail-secret-token-XPTO` securely within the project namespace.

#### Step 3: Create Policy and Access Token

```bash
# Create policy
POST /my-project/mcp/tools/POLICY_CREATE
Authorization: Bearer <project-token>
Content-Type: application/json

{
  "name": "Gmail Send Only",
  "statements": [
    {
      "effect": "allow",
      "resource": "SEND_EMAIL",
      "matchCondition": {
        "resource": "is_integration",
        "integrationId": "conn_abc123"
      }
    }
  ]
}

# Response:
{
  "id": "policy_123",
  "name": "Gmail Send Only"
}

# Create access token
POST /my-project/mcp/tools/TOKEN_CREATE
Authorization: Bearer <project-token>
Content-Type: application/json

{
  "name": "Engineering Team Gmail Access",
  "policyIds": ["policy_123"],
  "expiresIn": "90d"
}

# Response:
{
  "id": "token_xyz789",
  "token": "mesh_eyJhbGciOiJIUzI1NiIs...",
  "expiresAt": "2025-01-26T00:00:00Z"
}
```

The `mesh_eyJhbGciOiJIUzI1NiIs...` token contains:

- `aud`: "my-project" (project slug)
- `projectId`: "proj_abc123"
- `tokenId`: "token_xyz789"
- `policyIds`: ["policy_123"]
- Standard claims: `sub`, `iss`, `iat`, `exp`

#### Step 4: Use the Proxy API

```bash
POST /my-project/mcp/:connectionId
Authorization: Bearer mesh_eyJhbGciOiJIUzI1NiIs...
Content-Type: application/json

# Example: Call SEND_EMAIL tool via proxy
POST /my-project/mcp/conn_abc123
{
  "tool": "SEND_EMAIL",
  "arguments": {
    "to": "customer@example.com",
    "subject": "Welcome!",
    "body": "Thanks for signing up"
  }
}
```

**Behind the Scenes:**

1. Mesh validates the JWT token `mesh_eyJhbGciOiJIUzI1NiIs...`
2. Verifies `aud` claim matches project slug from URL path (`my-project`)
3. Extracts `tokenId` and `policyIds` → evaluates policies
4. Checks if `SEND_EMAIL` tool is allowed for `conn_abc123` per policy
5. Retrieves connection config and decrypts the Gmail token: `gmail-secret-token-XPTO`
6. Proxies the request to `https://mcp.gmail.com/mcp`:

   ```bash
   POST https://mcp.gmail.com/mcp
   Authorization: Bearer gmail-secret-token-XPTO
   Content-Type: application/json
   
   {
     "tool": "SEND_EMAIL",
     "arguments": { 
       "to": "customer@example.com",
       "subject": "Welcome!",
       "body": "Thanks for signing up"
     }
   }
   ```

7. Returns the response to the client
8. Logs the request in the audit log (project-scoped)

**Proxy API Specification:**

```typescript
// Proxy endpoint (project-scoped)
POST /:projectSlug/mcp/:connectionId

// Headers
Authorization: Bearer <mesh-issued-jwt with aud: projectSlug>
Content-Type: application/json

// Request Body (standard MCP format)
{
  "tool": string,
  "arguments": object
}

// Response (proxied from actual MCP service)
{
  "result": any,
  "error"?: string
}

// Error Responses
401 Unauthorized       // Invalid or expired token, or aud mismatch
403 Forbidden          // Tool not allowed by policy
404 Not Found          // Connection or project doesn't exist
500 Internal Error     // Proxy or downstream error
```

**Token Structure (JWT Claims):**

```typescript
interface MeshTokenPayload {
  // Standard JWT claims
  sub: string;           // Token ID or User ID
  iss: string;           // Mesh instance URL
  iat: number;           // Issued at
  exp: number;           // Expiration
  aud: string;           // Project slug (e.g., "my-project") - REQUIRED
  
  // Mesh-specific claims
  projectId: string;     // Project ID
  userId?: string;       // User ID (if user session token)
  tokenId?: string;      // Access token ID (if API token)
  policyIds: string[];   // Policy IDs that apply to this token
}
```

**Security Features:**

1. **Credential Isolation**: Original service tokens never leave the Mesh
2. **Encryption at Rest**: All credentials encrypted using AES-256-GCM
3. **Policy Enforcement**: Tools are checked before proxying
4. **Audit Trail**: Every request logged with full context
5. **Token Rotation**: Mesh tokens can be rotated without touching service credentials
6. **Instant Revocation**: Disable a Mesh token immediately without API calls to services

### Self-Hosting Guide

**Prerequisites:**

- Bun runtime (for local deployment), OR
- Docker (for containerized deployment)

That's it! No database setup required.

**Deployment Options:**

**Option 1: Standalone Binary (Recommended for Getting Started)**

```bash
# Download the latest release
curl -L https://github.com/your-org/mcp-mesh/releases/latest/download/mcp-mesh-linux -o mcp-mesh
chmod +x mcp-mesh

# Run with zero configuration
./mcp-mesh start

# The server starts immediately at http://localhost:3000
# SQLite database is automatically created at ./data/mesh.db
```

**Option 2: From Source**

```bash
# Clone and install
git clone https://github.com/your-org/mcp-mesh.git
cd mcp-mesh
bun install

# Run
bun run start
```

**Option 3: Docker (SQLite - Zero Config)**

```yaml
# docker-compose.yml
version: '3.8'

services:
  mesh:
    image: mcp-mesh/server:latest
    ports:
      - "3000:3000"
    volumes:
      - ./data:/app/data           # Persist SQLite database
      - ./auth-config.json:/app/auth-config.json  # Optional auth config
```

```bash
docker-compose up -d
```

**Option 4: Docker with PostgreSQL (Optional - for scale)**

Only needed if you expect high concurrent usage or want to run multiple Mesh instances.

```yaml
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:16
    environment:
      POSTGRES_DB: mcp_mesh
      POSTGRES_USER: mesh
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data

  mesh:
    image: mcp-mesh/server:latest
    depends_on:
      - postgres
    environment:
      DATABASE_URL: postgresql://mesh:${DB_PASSWORD}@postgres:5432/mcp_mesh
    ports:
      - "3000:3000"
    volumes:
      - ./auth-config.json:/app/auth-config.json  # Optional auth config

volumes:
  postgres_data:
```

**Environment Variables:**

MCP Mesh is designed with minimal configuration. Only **one** environment variable is supported:

```bash
# Database (optional - defaults to SQLite at ./data/mesh.db)
DATABASE_URL=postgresql://user:pass@host:5432/dbname
```

That's it! All other configuration is done via the optional `auth-config.json` file.

**Authentication Configuration** (`auth-config.json`):

Instead of environment variables, authentication is configured via an optional JSON file:

```json
{
  "emailAndPassword": {
    "enabled": true
  },
  "socialProviders": {
    "google": {
      "clientId": "your-google-client-id",
      "clientSecret": "your-google-client-secret"
    },
    "github": {
      "clientId": "your-github-client-id",
      "clientSecret": "your-github-client-secret"
    }
  },
  "saml": {
    "enabled": true,
    "providers": [
      {
        "name": "Okta",
        "entryPoint": "https://your-org.okta.com/app/...",
        "issuer": "http://www.okta.com/...",
        "cert": "-----BEGIN CERTIFICATE-----..."
      }
    ]
  }
}
```

**Production Considerations:**

1. **SSL/TLS**: Always use HTTPS in production (use a reverse proxy like Caddy or nginx)
2. **Database Backups**:
   - SQLite: Simple file-based backups (`cp data/mesh.db backups/mesh-$(date +%Y%m%d).db`)
   - PostgreSQL: Use `pg_dump` or automated backup solutions
3. **Secret Management**:
   - Secrets (JWT, encryption keys) are auto-generated on first run and stored in the database
   - Protect the `auth-config.json` file as it contains OAuth/SAML secrets
   - Use environment variable substitution in `auth-config.json` if needed for secret management
4. **Monitoring**: Set up health checks and alerting
5. **Rate Limiting**: Implement rate limits on proxy endpoints via reverse proxy
6. **Logging**: Configure structured logging for audit compliance
7. **Scaling**:
   - Single instance: SQLite is perfect
   - Multiple instances: Migrate to PostgreSQL with load balancer
8. **Project Isolation**: Each project operates in its own namespace with isolated credentials

---

## Roadmap

### Phase 1: Core Infrastructure (MVP)

- [x] Database schema design
- [x] Project/namespace architecture
- [ ] Authentication system (Better Auth with JSON config)
- [ ] Project management tools
- [ ] Connection management tools
- [ ] Policy and role management tools
- [ ] Token issuance and validation with `aud` claim
- [ ] Basic proxy implementation (`/:project/mcp/:connectionId`)
- [ ] Audit logging (project-scoped)

### Phase 2: Security & Access Control

- [ ] Fine-grained policy engine with statements
- [ ] Role-based access control
- [ ] Team and member management
- [ ] Credential encryption (AES-256-GCM)
- [ ] Token revocation
- [ ] Rate limiting per project

### Phase 3: Developer Experience

- [ ] CLI tool for project and connection management
- [ ] TypeScript/Python SDKs
- [ ] Web-based admin UI
- [ ] Connection testing tools
- [ ] Interactive documentation
- [ ] Project templates

### Phase 4: Advanced Features

- [ ] Tool composition across connections
- [ ] MCP dependency resolution
- [ ] Response caching layer
- [ ] Webhook support for events
- [ ] Metrics and analytics dashboard (per project)
- [ ] Multi-region deployment support

---

## Contributing

We welcome contributions! Please see our [CONTRIBUTING.md](./CONTRIBUTING.md) for guidelines.

## License

MCP Mesh is open-source software licensed under the [MIT License](./LICENSE).
