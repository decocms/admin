---
title: Building Views
description: Create custom React interfaces that share context with your backend
icon: Globe
---

import Callout from "../../../components/ui/Callout.astro";

deco gives you a **full React frontend** that lives alongside your backend—same codebase, shared types, unified deployment. Unlike traditional setups where you build REST APIs to connect frontend and backend, deco uses **typed RPC**: your React components call backend tools directly, with full type safety.

<Callout type="success">
  **Key difference**: Your UI and agents share the same tools, the same database, the same context. No duplicate APIs, no integration hell, no CORS—just TypeScript.
</Callout>

## Frontend Stack

The view layer is built with modern React tooling:

- **[React 19](https://react.dev/)** – UI library with latest features (async components, server actions)
- **[Vite](https://vitejs.dev/)** – Lightning-fast bundler with hot module reload
- **[TanStack Router](https://tanstack.com/router)** – Type-safe routing (better than React Router)
- **[Tailwind CSS](https://tailwindcss.com/)** – Utility-first styling
- **[shadcn/ui](https://ui.shadcn.com/)** – Beautiful, accessible component library

All tooling is pre-configured. Just start building your UI.

## Setting up the View

If you used a template with a view, the basics should already be configured:

- The CSS is managed by Tailwind (check `tailwind.config.js` if present, and global styles might be applied via an index CSS or within components).

- Routing: The template likely has a `routes/index.tsx` for the home route, and additional route files. New pages can be created by adding new files in `src/routes` and wiring them into the router in `main.tsx` (as shown in the template example).

- State management: Not specifically included by deco by default, but since this is a React app, you can use React context or libraries like Zustand, etc., if needed. For simple apps, you might not need any global state beyond what React Query or the RPC calls provide.

## Typed RPC: Frontend ↔ Backend

The RPC client (`src/lib/rpc.ts`) is your gateway to the backend. It's **type-safe, auto-complete-enabled, and zero-boilerplate**—no REST endpoints to write, no OpenAPI specs to maintain.

### How It Works

1. **Backend defines tools/workflows** in `server/tools/` and `server/workflows/`
2. **Run `npm run gen:self`** to regenerate `deco.gen.ts` with types
3. **Frontend imports `client`** and calls tools/workflows as methods

```typescript
// view/src/lib/rpc.ts
import { createClient } from "@deco/workers-runtime/client";
import type { Env } from "../../server/deco.gen.ts";

type SelfMCP = Env["SELF"];
export const client = createClient<SelfMCP>();
```

### Calling Tools

```tsx
// view/src/components/EmailButton.tsx
import { client } from "../lib/rpc";
import { Button } from "./ui/button";
import { useState } from "react";

export function EmailButton() {
  const [sending, setSending] = useState(false);

  const sendEmail = async () => {
    setSending(true);
    try {
      // ✅ Type-safe call: TypeScript knows input/output types
      const result = await client.tools.SEND_EMAIL({
        to: "user@example.com",
        subject: "Hello!",
        body: "Welcome to deco.",
      });

      if (result.success) {
        alert("Email sent!");
      }
    } catch (error) {
      alert("Failed to send email.");
    } finally {
      setSending(false);
    }
  };

  return (
    <Button onClick={sendEmail} disabled={sending}>
      {sending ? "Sending..." : "Send Email"}
    </Button>
  );
}
```

<Callout type="info">
  **Behind the scenes**: The RPC client makes HTTP requests to your Cloudflare Worker at `/mcp`. The Worker routes them to the appropriate tool/workflow. But from your perspective, it's just a function call.
</Callout>

### Calling Workflows

Workflows run asynchronously in the background. Use `.start()` to begin execution, then `.waitForCompletion()` to poll for results:

```tsx
// view/src/components/CustomerRegistrationForm.tsx
import { client } from "../lib/rpc";
import { Button } from "./ui/button";
import { useState } from "react";

export function CustomerRegistrationForm() {
  const [processing, setProcessing] = useState(false);
  const [customerId, setCustomerId] = useState<number | null>(null);

  const handleSubmit = async (data: {
    name: string;
    cpf: string;
    cep: string;
  }) => {
    setProcessing(true);
    try {
      // ✅ Start workflow execution
      const runId = await client.workflows.REGISTER_CUSTOMER.start(data);

      // ✅ Wait for workflow to complete
      const result = await client.workflows.REGISTER_CUSTOMER.waitForCompletion(runId);

      setCustomerId(result.customerId);
      alert(`Customer registered! ID: ${result.customerId}`);
    } catch (error) {
      alert("Registration failed.");
    } finally {
      setProcessing(false);
    }
  };

  return (
    <div>
      {/* Form fields here */}
      <Button onClick={() => handleSubmit({...})} disabled={processing}>
        {processing ? "Processing..." : "Register"}
      </Button>
      {customerId && <p>Success! Customer ID: {customerId}</p>}
    </div>
  );
}
```

<Callout type="tip">
  **Alternative**: For long-running workflows, use webhooks instead of polling. Set up a webhook endpoint to receive notifications when workflows complete.
</Callout>

### Error Handling

Handle errors like any async function:

```tsx
try {
  const result = await client.tools.SEND_EMAIL({...});
  // Success path
} catch (error) {
  if (error instanceof Error) {
    console.error("Tool call failed:", error.message);
  }
  // Error path
}
```

### Type Safety

TypeScript enforces correctness at compile time:

```tsx
// ✅ Correct: All required fields provided
await client.tools.SEND_EMAIL({
  to: "user@example.com",
  subject: "Hello",
  body: "Welcome",
});

// ❌ Error: Missing 'body' field
await client.tools.SEND_EMAIL({
  to: "user@example.com",
  subject: "Hello",
  // TypeScript error: Property 'body' is missing
});

// ❌ Error: Wrong type for 'to' field
await client.tools.SEND_EMAIL({
  to: 123,  // TypeScript error: Type 'number' is not assignable to type 'string'
  subject: "Hello",
  body: "Welcome",
});
```

## Routing and Navigation

The template uses **TanStack Router**, which is a type-safe router similar in spirit to React Router. Routes are defined as functions that create route objects. For instance, a `MyPage.tsx` might export `export default (parentRoute) => createRoute({...})` which is then imported in `main.tsx` and added to the route tree. You can organize nested routes, layouts, and so on. The exact details aren't crucial for getting started – just know that to add a new page, you likely:

1. Create a new file in `routes/` directory, define the component and route.
2. Import and include that route in the route tree in `main.tsx`.
3. Add a navigation link or programmatic navigation as needed.

## UI Components

Tailwind makes styling easier by using classes directly in JSX. You might have pre-made components (buttons, forms, etc.) in `src/components`. Feel free to build your own or integrate a design system. The key is that the frontend can be any React app; deco doesn't impose much beyond the RPC setup. So you can use React libraries (charts, modals, etc.) as you normally would.

## Connecting to Tools/Workflows

We covered RPC usage. It's worth noting that because the RPC client is generated from your types, if you add a new tool and re-run `npm run gen`, your `client` will automatically have the new method. This prevents calling something that doesn't exist. If you try to call a tool that you didn't list in `withRuntime` on the server, the TypeScript compiler will complain (and at runtime it would 404). So always update the generation after adding new capabilities, and update your UI accordingly.

## Hot Reload & Development

During `npm run dev`, if you edit a React component, HMR (Hot Module Reloading) will update it in the browser without a full refresh. If you edit server code (a tool/workflow), the Worker will restart (the CLI/dev script handles this) and you may need to refresh the page or re-run the action. Check the terminal for any errors on the server side when developing.

In summary, building the view is just like building any React web app, but with the advantage that your backend is just a function call away via the client. This means you don't have to set up separate REST or GraphQL endpoints for your AI logic – it's all unified.

_(If you prefer not to have a custom view, you can ignore/remove the `/view` folder. Agents can also be used purely via API or the deco web interface. But for custom applications, the view is where you create tailored experiences for end-users.)_
