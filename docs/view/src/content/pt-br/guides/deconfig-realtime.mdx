---
title: Deconfig Resources - Recursos Persistentes em Tempo Real
description: Crie recursos de configura√ß√£o tipados, persistentes e sincronizados em tempo real
icon: Database
---

import Callout from "../../../components/ui/Callout.astro";

**DeconfigResource** fornece um sistema poderoso para criar recursos de configura√ß√£o tipados, persistentes e sincronizados em tempo real. √â ideal para configura√ß√µes de UI, temas, prefer√™ncias de usu√°rio e quaisquer dados de configura√ß√£o que precisam ser armazenados, validados e atualizados instantaneamente em todos os clientes conectados.

## Vis√£o Geral

DeconfigResource aproveita o padr√£o Resources 2.0 com:

- **Persist√™ncia baseada em arquivos** usando o sistema de diret√≥rios DECONFIG
- **Schemas com tipagem segura** com valida√ß√£o Zod
- **Opera√ß√µes CRUD completas** (Create, Read, Update, Delete, Search)
- **Sincroniza√ß√£o em tempo real** via Server-Sent Events (SSE)
- **URIs padronizadas** seguindo o formato `rsc://`
- **Rastreamento de metadados** (created_by, updated_by, timestamps)

---

## 1. Definindo um Resource (Backend)

Crie uma defini√ß√£o de recurso no seu arquivo de tools (ex: `server/tools/index.ts`). O schema de dados √© definido usando Zod para valida√ß√£o de tipo em tempo de execu√ß√£o.

### Exemplo: Resource de Configura√ß√µes de Tema

```typescript
// 1. Importe DeconfigResource e zod
import { DeconfigResource } from "@decocms/runtime/deconfig";
import { z } from "zod";
import type { Env } from '../main.ts';

// 2. Defina o Schema para o seu Resource
const ThemeSettings = DeconfigResource.define({
  dataSchema: z.object({
    name: z.string().min(1).describe("Nome do tema"),
    description: z.string().describe("Descri√ß√£o do tema"),
    primaryColor: z.string().regex(/^#[0-9A-Fa-f]{6}$/).describe("Cor prim√°ria (hex)"),
    secondaryColor: z.string().regex(/^#[0-9A-Fa-f]{6}$/).describe("Cor secund√°ria (hex)"),
    textColor: z.string().regex(/^#[0-9A-Fa-f]{6}$/).describe("Cor do texto (hex)"),
  }),
  resourceName: "theme_settings", // Nome do diret√≥rio do resource (rsc://app-id/theme_settings/*)
});

// 3. Exporte o criador de resource na sua lista de tools
export const tools = [
  // ... outras tools
  (env: Env) => {
    return ThemeSettings.create(env);
  },
];

// 4. Exporte a defini√ß√£o do Resource (opcional, para uso no frontend)
export { ThemeSettings };
```

### Op√ß√µes de Configura√ß√£o

```typescript
DeconfigResource.define({
  dataSchema: z.object({ /* seu schema */ }),      // Obrigat√≥rio: Schema Zod para valida√ß√£o
  resourceName: "my_resource",                       // Obrigat√≥rio: Identificador do tipo de resource
  directory?: "/custom/path",                        // Opcional: Diret√≥rio de armazenamento customizado (padr√£o: /resources/{resourceName})
  enhancements?: {                                   // Opcional: Descri√ß√µes customizadas para tools geradas
    DECO_RESOURCE_MY_RESOURCE_SEARCH: {
      description: "Descri√ß√£o de busca customizada"
    },
  },
  validate?: async (data) => {                       // Opcional: Valida√ß√£o sem√¢ntica adicional
    if (data.name === "proibido") {
      throw new Error("Nome n√£o permitido");
    }
  }
})
```

---

## 2. Opera√ß√µes Dispon√≠veis

Ap√≥s definir um resource e executar a gera√ß√£o de c√≥digo (`deco gen` ou equivalente), as seguintes tools MCP s√£o criadas automaticamente:

### Matriz de Opera√ß√µes CRUD

| Opera√ß√£o | Padr√£o do Nome do M√©todo | Descri√ß√£o |
|-----------|-------------------|-------------|
| **Create** | `DECO_RESOURCE_{NAME}_CREATE` | Cria um novo resource |
| **Read** | `DECO_RESOURCE_{NAME}_READ` | L√™ um resource por URI |
| **Search** | `DECO_RESOURCE_{NAME}_SEARCH` | Lista/busca resources com filtragem, ordena√ß√£o e pagina√ß√£o |
| **Update** | `DECO_RESOURCE_{NAME}_UPDATE` | Atualiza um resource existente por URI |
| **Delete** | `DECO_RESOURCE_{NAME}_DELETE` | Deleta um resource por URI |
| **Describe** | `DECO_RESOURCE_{NAME}_DESCRIBE` | Obt√©m metadados e endpoint SSE watch |

<Callout type="info">
  `{NAME}` √© a vers√£o em mai√∫sculas do seu `resourceName`. Por exemplo, `theme_settings` se torna `THEME_SETTINGS`.
</Callout>

### Formato de URI do Resource

Resources seguem o formato de URI padr√£o do Resources 2.0:

```
rsc://{integrationId}/{resourceName}/{resourceId}
```

Exemplo:
```
rsc://my-app-123/theme_settings/dark-theme
```

### Par√¢metros de Busca

A opera√ß√£o `SEARCH` suporta filtragem e pagina√ß√£o poderosas:

```typescript
client.DECO_RESOURCE_THEME_SETTINGS_SEARCH({
  term?: string,              // Busca em resourceId, name, description, created_by, updated_by
  page?: number,              // N√∫mero da p√°gina (padr√£o: 1)
  pageSize?: number,          // Itens por p√°gina (padr√£o: 10, use Infinity para todos)
  filters?: {
    created_by?: string | string[],
    updated_by?: string | string[],
  },
  sortBy?: "resourceId" | "name" | "description" | "mtime",
  sortOrder?: "asc" | "desc",
})
```

---

## 3. Consumo em Tempo Real (Frontend)

### A. Opera√ß√µes CRUD B√°sicas

Use os m√©todos do cliente gerados para opera√ß√µes padr√£o:

```typescript
import { client } from './your-client';

// Create
const newTheme = await client.DECO_RESOURCE_THEME_SETTINGS_CREATE({
  data: {
    name: "Tema Escuro",
    description: "Um esquema de cores escuro",
    primaryColor: "#1a1a1a",
    secondaryColor: "#2d2d2d",
    textColor: "#ffffff",
  }
});

// Read
const theme = await client.DECO_RESOURCE_THEME_SETTINGS_READ({
  uri: "rsc://my-app/theme_settings/dark-theme"
});

// Update
const updated = await client.DECO_RESOURCE_THEME_SETTINGS_UPDATE({
  uri: "rsc://my-app/theme_settings/dark-theme",
  data: {
    primaryColor: "#000000", // Mudan√ßas s√£o mescladas com dados existentes
  }
});

// Delete
await client.DECO_RESOURCE_THEME_SETTINGS_DELETE({
  uri: "rsc://my-app/theme_settings/dark-theme"
});

// Search
const results = await client.DECO_RESOURCE_THEME_SETTINGS_SEARCH({
  term: "escuro",
  page: 1,
  pageSize: 10,
});
```

### B. Sincroniza√ß√£o em Tempo Real com SSE

Para atualiza√ß√µes ao vivo em todos os clientes conectados, use Server-Sent Events:

```typescript
import { useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { client } from './your-client';

function useThemeRealtime() {
  const queryClient = useQueryClient();

  useEffect(() => {
    const setupSSE = async () => {
      // 1. Obtenha o endpoint SSE e template de URI
      const description = await client.DECO_RESOURCE_THEME_SETTINGS_DESCRIBE({});
      const watchPathname = description.features?.watch?.pathname;
      const uriTemplate = description.uriTemplate; // ex: rsc://my-app/theme_settings/*

      if (!watchPathname) return;

      // 2. Construa a URL SSE (inscreva-se em todos os resources com *)
      const watchUrl = `${watchPathname}?uri=${encodeURIComponent(uriTemplate)}`;

      // 3. Conecte-se ao stream SSE
      const eventSource = new EventSource(watchUrl);

      eventSource.onmessage = async (event) => {
        const update = JSON.parse(event.data);
        
        // update.uri cont√©m a URI do resource alterado
        if (update.uri) {
          // Invalide queries para disparar refetch
          queryClient.invalidateQueries({ queryKey: ["themes"] });
          
          // Ou busque o resource espec√≠fico
          // const updatedData = await client.DECO_RESOURCE_THEME_SETTINGS_READ({
          //   uri: update.uri
          // });
        }
      };

      eventSource.onerror = (error) => {
        console.error("Erro de conex√£o SSE:", error);
        eventSource.close();
      };

      // Cleanup
      return () => {
        eventSource.close();
      };
    };

    const cleanup = setupSSE();
    return () => {
      cleanup.then(fn => fn?.());
    };
  }, [queryClient]);
}
```

### C. Exemplo Completo com React Query

Aqui est√° um exemplo completo combinando opera√ß√µes CRUD com atualiza√ß√µes em tempo real:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useEffect } from 'react';
import { client } from './your-client';

export function useThemeSettings() {
  const queryClient = useQueryClient();

  // Buscar todos os temas
  const { data: themes, isLoading } = useQuery({
    queryKey: ["themes"],
    queryFn: async () => {
      const result = await client.DECO_RESOURCE_THEME_SETTINGS_SEARCH({
        pageSize: Infinity,
      });
      return result.items;
    },
  });

  // Mutation de cria√ß√£o
  const createTheme = useMutation({
    mutationFn: async (data: ThemeData) => {
      return client.DECO_RESOURCE_THEME_SETTINGS_CREATE({ data });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["themes"] });
    },
  });

  // Mutation de atualiza√ß√£o
  const updateTheme = useMutation({
    mutationFn: async ({ uri, data }: { uri: string; data: Partial<ThemeData> }) => {
      return client.DECO_RESOURCE_THEME_SETTINGS_UPDATE({ uri, data });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["themes"] });
    },
  });

  // Inscri√ß√£o SSE em tempo real
  useEffect(() => {
    let eventSource: EventSource | null = null;

    const setupSSE = async () => {
      try {
        const description = await client.DECO_RESOURCE_THEME_SETTINGS_DESCRIBE({});
        const watchPathname = description.features?.watch?.pathname;
        const uriTemplate = description.uriTemplate;

        if (watchPathname) {
          const watchUrl = `${watchPathname}?uri=${encodeURIComponent(uriTemplate)}`;
          eventSource = new EventSource(watchUrl);

          eventSource.onmessage = (event) => {
            const update = JSON.parse(event.data);
            if (update.uri) {
              queryClient.invalidateQueries({ queryKey: ["themes"] });
            }
          };
        }
      } catch (error) {
        console.error("Falha ao configurar SSE:", error);
      }
    };

    setupSSE();

    return () => {
      eventSource?.close();
    };
  }, [queryClient]);

  return {
    themes,
    isLoading,
    createTheme: createTheme.mutate,
    updateTheme: updateTheme.mutate,
  };
}
```

---

## 4. Recursos Avan√ßados

### Valida√ß√£o Customizada

Adicione valida√ß√£o sem√¢ntica al√©m das verifica√ß√µes de schema:

```typescript
const UserSettings = DeconfigResource.define({
  dataSchema: z.object({
    username: z.string(),
    email: z.string().email(),
  }),
  resourceName: "user_settings",
  validate: async (data) => {
    // Verifique se o nome de usu√°rio j√° est√° em uso
    const existing = await checkUsernameExists(data.username);
    if (existing) {
      throw new Error("Nome de usu√°rio j√° existe");
    }
  },
});
```

### Diret√≥rio de Armazenamento Customizado

Sobrescreva a localiza√ß√£o de armazenamento padr√£o:

```typescript
const PrivateSettings = DeconfigResource.define({
  dataSchema: /* ... */,
  resourceName: "private_settings",
  directory: "/private/user_settings", // Caminho customizado
});
```

### Observar Resources Espec√≠ficos

Em vez de observar todos os resources (`*`), observe um espec√≠fico:

```typescript
// Observe apenas um resource espec√≠fico
const specificUri = "rsc://my-app/theme_settings/dark-theme";
const watchUrl = `${watchPathname}?uri=${encodeURIComponent(specificUri)}`;
```

### Sinaliza√ß√£o em Tempo Real para Fontes de Dados Externas

Voc√™ tamb√©m pode criar um Deconfig Resource como um **mecanismo de sinaliza√ß√£o** para propagar atualiza√ß√µes em tempo real para dados que vivem em fontes externas como Airtable, Google Sheets ou APIs de terceiros.

Este padr√£o √© √∫til quando:
- Seus dados reais est√£o armazenados externamente
- Voc√™ quer que todos os clientes conectados refa√ßam o fetch quando os dados externos mudam
- Voc√™ precisa rastrear "salas" ou "canais" para diferentes conjuntos de dados

#### Exemplo: Integra√ß√£o Airtable com Atualiza√ß√µes em Tempo Real

Imagine que voc√™ tem uma tabela Airtable com ferramentas de integra√ß√£o √†s quais seus usu√°rios podem se conectar. Voc√™ quer que todos os clientes vejam atualiza√ß√µes imediatamente quando algu√©m adiciona ou modifica uma ferramenta.

**Passo 1: Defina um Resource de Sinaliza√ß√£o M√≠nimo**

```typescript
// Este resource n√£o armazena os dados reais do Airtable
// √â apenas um "sinal" para notificar clientes quando refazer o fetch
const AirtableSync = DeconfigResource.define({
  dataSchema: z.object({
    name: z.string().describe("Identificador da sala de sincroniza√ß√£o"),
    description: z.string().describe("O que esta sincroniza√ß√£o rastreia"),
    lastSyncAt: z.string().datetime().describe("Timestamp da √∫ltima sincroniza√ß√£o"),
    syncedBy: z.string().optional().describe("Usu√°rio que disparou a sincroniza√ß√£o"),
  }),
  resourceName: "airtable_sync",
});

export const tools = [
  (env: Env) => AirtableSync.create(env),
];
```

**Passo 2: Crie uma Tool para Disparar Notifica√ß√µes de Sincroniza√ß√£o**

```typescript
// No seu arquivo de tools
export const tools = [
  // ... Resource de sincroniza√ß√£o Airtable
  {
    name: "NOTIFY_AIRTABLE_UPDATE" as const,
    inputSchema: z.object({
      tableId: z.string(),
    }),
    outputSchema: z.object({
      success: z.boolean(),
    }),
    handler: async ({ tableId }, env) => {
      // Atualize o resource de sincroniza√ß√£o para disparar notifica√ß√µes SSE
      const uri = `rsc://${env.DECO_REQUEST_CONTEXT.integrationId}/airtable_sync/${tableId}`;
      
      await client.DECO_RESOURCE_AIRTABLE_SYNC_UPDATE({
        uri,
        data: {
          name: tableId,
          description: `Tabela de ferramentas ${tableId}`,
          lastSyncAt: new Date().toISOString(),
          syncedBy: env.DECO_REQUEST_CONTEXT.ensureAuthenticated()?.id,
        },
      });

      return { success: true };
    },
  },
];
```

**Passo 3: Hook Frontend com Dados Externos + Tempo Real**

```typescript
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useEffect } from 'react';

// Sua fun√ß√£o real de busca no Airtable
async function fetchAirtableTools(tableId: string) {
  const response = await fetch(`https://api.airtable.com/v0/${tableId}/tools`, {
    headers: { Authorization: `Bearer ${AIRTABLE_TOKEN}` },
  });
  return response.json();
}

export function useAirtableTools(tableId: string) {
  const queryClient = useQueryClient();

  // Consulte os dados reais do Airtable
  const { data: tools, isLoading } = useQuery({
    queryKey: ["airtable-tools", tableId],
    queryFn: () => fetchAirtableTools(tableId),
  });

  // Inscreva-se no resource de sincroniza√ß√£o para atualiza√ß√µes em tempo real
  useEffect(() => {
    let eventSource: EventSource | null = null;

    const setupSSE = async () => {
      // Obtenha o endpoint de observa√ß√£o
      const description = await client.DECO_RESOURCE_AIRTABLE_SYNC_DESCRIBE({});
      const watchPathname = description.features?.watch?.pathname;
      
      // Observe o resource de sincroniza√ß√£o espec√≠fico para esta tabela
      const specificUri = `rsc://my-app/airtable_sync/${tableId}`;
      const watchUrl = `${watchPathname}?uri=${encodeURIComponent(specificUri)}`;

      eventSource = new EventSource(watchUrl);

      eventSource.onmessage = (event) => {
        const update = JSON.parse(event.data);
        
        // Quando o resource de sincroniza√ß√£o muda, refa√ßa o fetch dos dados do Airtable
        if (update.uri) {
          console.log("Dados do Airtable mudaram, refazendo fetch...");
          queryClient.invalidateQueries({ 
            queryKey: ["airtable-tools", tableId] 
          });
        }
      };
    };

    setupSSE();

    return () => {
      eventSource?.close();
    };
  }, [tableId, queryClient]);

  return {
    tools,
    isLoading,
  };
}
```

**Passo 4: Dispare a Sincroniza√ß√£o de Qualquer Lugar**

**Preferido: Tool Backend Dispara Sincroniza√ß√£o** ‚≠ê

A melhor pr√°tica √© disparar notifica√ß√µes de sincroniza√ß√£o diretamente das suas tools backend que modificam dados externos. Isso garante consist√™ncia e que todos os clientes sejam notificados.

```typescript
// No seu arquivo de tools - uma tool que escreve no Airtable
export const tools = [
  // ... outras tools
  {
    name: "ADD_AIRTABLE_TOOL" as const,
    inputSchema: z.object({
      tableId: z.string(),
      toolName: z.string(),
      toolDescription: z.string(),
    }),
    outputSchema: z.object({
      success: z.boolean(),
      recordId: z.string(),
    }),
    handler: async ({ tableId, toolName, toolDescription }, env) => {
      // 1. Escreva no Airtable
      const airtableResponse = await fetch(
        `https://api.airtable.com/v0/${tableId}/tools`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${env.AIRTABLE_API_KEY}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            fields: {
              name: toolName,
              description: toolDescription,
            },
          }),
        }
      );

      const record = await airtableResponse.json();

      // 2. Notifique todos os clientes conectados que os dados mudaram
      const uri = `rsc://${env.DECO_REQUEST_CONTEXT.integrationId}/airtable_sync/${tableId}`;
      
      await client.DECO_RESOURCE_AIRTABLE_SYNC_UPDATE({
        uri,
        data: {
          name: tableId,
          description: `Tabela de ferramentas ${tableId}`,
          lastSyncAt: new Date().toISOString(),
          syncedBy: env.DECO_REQUEST_CONTEXT.ensureAuthenticated()?.id,
        },
      });

      // 3. Todos os clientes observando este tableId automaticamente refazem o fetch
      return {
        success: true,
        recordId: record.id,
      };
    },
  },
];
```

**Alternativa: Manipulador de Webhook**

```typescript
// Quando o Airtable envia um webhook sobre mudan√ßas externas
async function onAirtableWebhook(tableId: string) {
  await client.NOTIFY_AIRTABLE_UPDATE({ tableId });
  // Todos os clientes observando este tableId automaticamente refazem o fetch
}
```

**Alternativa: Disparo Manual na UI**

```typescript
// Para atualiza√ß√£o manual da UI
<Button onClick={() => client.NOTIFY_AIRTABLE_UPDATE({ tableId: "appXXX" })}>
  Sincronizar Airtable
</Button>
```

#### Benef√≠cios deste Padr√£o

‚úÖ **Armazenamento M√≠nimo**: O resource armazena apenas metadados de sincroniza√ß√£o, n√£o os dados externos completos  
‚úÖ **Broadcast em Tempo Real**: Todos os clientes conectados recebem notifica√ß√µes instant√¢neas  
‚úÖ **Fonte √önica da Verdade**: Os dados reais permanecem na fonte externa  
‚úÖ **Flex√≠vel**: Funciona com qualquer API externa (Airtable, Notion, Google Sheets, etc.)  
‚úÖ **Padr√£o Sala/Canal**: Crie diferentes resources para diferentes conjuntos de dados ou equipes

#### Outros Casos de Uso

- **Notifica√ß√µes de Mudan√ßa de Banco de Dados**: Sinalize quando uma tabela de banco de dados externa √© atualizada
- **Relay de Webhook**: Converta webhooks recebidos em notifica√ß√µes de cliente em tempo real
- **Edi√ß√£o Colaborativa**: Rastreie "salas" onde m√∫ltiplos usu√°rios est√£o editando documentos externos
- **Invalida√ß√£o de Cache**: Coordene invalida√ß√£o de cache entre m√∫ltiplas inst√¢ncias de frontend
- **Status de Pipeline de Dados**: Notifique clientes quando jobs ETL ou processamento de dados s√£o conclu√≠dos

---

## 5. Melhores Pr√°ticas

### Nomenclatura de Resource

- Use **snake_case** para `resourceName` (ex: `theme_settings`, `user_preferences`)
- Mantenha nomes descritivos mas concisos
- Evite caracteres especiais

### Design de Schema

- Inclua campos `name` e `description` para melhor buscabilidade
- Use `.describe()` nos campos Zod para documenta√ß√£o gerada
- Valide formatos rigorosamente (ex: cores, emails, URLs)

```typescript
z.object({
  name: z.string().min(1).describe("Nome de exibi√ß√£o"),
  description: z.string().describe("Descri√ß√£o para este resource"),
  email: z.string().email().describe("Endere√ßo de email do usu√°rio"),
  website: z.string().url().optional().describe("URL opcional do website"),
})
```

### Tratamento de Erros

O sistema lan√ßa erros espec√≠ficos que voc√™ deve tratar:

```typescript
import { NotFoundError, UserInputError } from '@decocms/runtime/deconfig';

try {
  const theme = await client.DECO_RESOURCE_THEME_SETTINGS_READ({ uri });
} catch (error) {
  if (error instanceof NotFoundError) {
    // Resource n√£o existe
  } else if (error instanceof UserInputError) {
    // Valida√ß√£o falhou ou conflito ocorreu
  }
}
```

### Otimiza√ß√£o de Performance

- Use `pageSize: Infinity` apenas quando necess√°rio; prefira pagina√ß√£o para grandes conjuntos de dados
- Implemente debouncing para atualiza√ß√µes frequentes
- Use `staleTime` do React Query para reduzir refetches desnecess√°rios

```typescript
const { data } = useQuery({
  queryKey: ["themes"],
  queryFn: fetchThemes,
  staleTime: 5 * 60 * 1000, // 5 minutos
});
```

### Gerenciamento de Conex√£o SSE

- Sempre feche conex√µes EventSource na limpeza
- Trate erros de conex√£o e implemente l√≥gica de reconex√£o
- Considere usar uma √∫nica conex√£o SSE para m√∫ltiplos tipos de resource

```typescript
eventSource.onerror = () => {
  eventSource.close();
  // Implemente reconex√£o com backoff exponencial
  setTimeout(() => setupSSE(), retryDelay);
};
```

---

## Refer√™ncia da API

### DeconfigResource.define()

Define um novo tipo de resource com schema e configura√ß√£o.

```typescript
DeconfigResource.define<TDataSchema>({
  dataSchema: ZodSchema,
  resourceName: string,
  directory?: string,
  enhancements?: EnhancedResourcesTools<TDataSchema>,
  validate?: (data: z.infer<TDataSchema>) => Promise<void>,
})
```

**Retorna:** Um objeto com:
- `create(env)`: Fun√ß√£o para criar as tools do resource
- `watcher`: Fun√ß√£o watcher interna (uso avan√ßado)

### DeconfigResource.watchAPI()

Manipula requisi√ß√µes de observa√ß√£o SSE (usado internamente pelo runtime).

```typescript
DeconfigResource.watchAPI(req: Request, env: DefaultEnv)
```

**Retorna:** Uma `Response` com stream SSE (`text/event-stream`)

---

## Solu√ß√£o de Problemas

### "Cannot find module '@decocms/runtime/deconfig'"

Certifique-se de ter executado o passo de build/gera√ß√£o ap√≥s definir resources:

```bash
deco gen
# ou
npm run build
```

### Falha na Conex√£o SSE

1. Verifique se a opera√ß√£o `DESCRIBE` retorna um `features.watch.pathname` v√°lido
2. Verifique se o formato do template URI corresponde a `rsc://{integrationId}/{resourceName}/*`
3. Certifique-se de que os headers CORS est√£o configurados corretamente para seu dom√≠nio

### Resource N√£o Encontrado Ap√≥s Cria√ß√£o

1. Verifique se o resource foi criado com sucesso (verifique a URI retornada)
2. Certifique-se de estar usando o formato de URI correto ao ler
3. Verifique as permiss√µes de arquivo no diret√≥rio DECONFIG

---

## Recursos Adicionais

- [Especifica√ß√£o do Padr√£o Resources 2.0](https://github.com/deco-cx/chat/blob/main/packages/runtime/src/bindings/resources/bindings.ts) (C√≥digo Fonte)
- [Documenta√ß√£o Zod](https://zod.dev)
- [Guia de Server-Sent Events (SSE)](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
- [Documenta√ß√£o React Query](https://tanstack.com/query/latest)

---

**Bora construir! üöÄ**

Para d√∫vidas ou problemas, consulte a documenta√ß√£o principal do reposit√≥rio ou abra uma issue.

